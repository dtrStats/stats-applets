<!-- INSTRUCTOR EDITS: Change DEFAULT_N, DEFAULT_SIMS, and DEFAULT_SHAPE in the script below to set startup defaults. To change slider limits, edit the min/max/step attributes on the two range inputs in the controls section. -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sampling Distribution of the Mean</title>
  <style>
    :root {
      --bg: #f6f8fb;
      --panel: #ffffff;
      --ink: #1f2937;
      --muted: #6b7280;
      --accent: steelblue;
      --border: #d7deea;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: var(--bg);
      color: var(--ink);
      line-height: 1.4;
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px;
    }

    h1 {
      margin: 0 0 14px;
      font-size: 1.9rem;
      text-align: center;
    }

    .sub {
      text-align: center;
      color: var(--muted);
      margin: 0 0 18px;
      font-size: 0.98rem;
    }

    .grid {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 16px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.04);
    }

    .controls .control {
      margin-bottom: 16px;
    }

    .controls label {
      display: block;
      font-weight: 700;
      margin-bottom: 6px;
    }

    .value-badge {
      color: var(--accent);
      font-weight: 700;
    }

    input[type="range"] {
      width: 100%;
      cursor: pointer;
    }

    select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #fff;
      font-size: 0.98rem;
    }

    .btn-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    button {
      border: 0;
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      font-size: 0.95rem;
    }

    .run-btn {
      background: var(--accent);
      color: #fff;
    }

    .reset-btn {
      background: #e5e7eb;
      color: #111827;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      padding: 6px 0;
      border-bottom: 1px solid #edf1f7;
    }

    .stat-row:last-child {
      border-bottom: 0;
    }

    .stat-label {
      color: var(--muted);
    }

    .stat-value {
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }

    .plot-title {
      text-align: center;
      font-weight: 700;
      margin-bottom: 8px;
      font-size: 1.05rem;
    }

    canvas {
      display: block;
      width: 100%;
      max-width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
    }

    .interp {
      min-height: 78px;
      color: #111827;
    }

    .note {
      color: var(--muted);
      font-size: 0.9rem;
      margin-top: 6px;
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Sampling Distribution of the Mean</h1>
    <p class="sub">Explore how the distribution of sample means becomes tighter and more nearly normal as sample size increases.</p>

    <div class="grid">
      <div>
        <div class="panel controls">
          <div class="control">
            <label for="nSlider">Sample size n: <span class="value-badge" id="nValue">30</span></label>
            <input id="nSlider" type="range" min="5" max="200" step="1" value="30" />
          </div>

          <div class="control">
            <label for="simSlider">Number of simulations: <span class="value-badge" id="simValue">1000</span></label>
            <input id="simSlider" type="range" min="100" max="5000" step="100" value="1000" />
          </div>

          <div class="control">
            <label for="shapeSelect">Population shape</label>
            <select id="shapeSelect">
              <option value="normal">Normal</option>
              <option value="skewed">Right-skewed</option>
              <option value="bimodal">Bimodal</option>
            </select>
          </div>

          <div class="btn-row">
            <button class="run-btn" id="runBtn">Run Simulation</button>
            <button class="reset-btn" id="resetBtn">Reset</button>
          </div>

          <div class="note">
            Population generators: Normal uses Box-Muller with &mu; = 50, &sigma; = 10; Right-skewed uses Exp(&lambda; = 0.1); Bimodal mixes 50% from N(30, 5) and 50% from N(70, 5).
          </div>
        </div>

        <div class="panel" style="margin-top:16px;" aria-live="polite">
          <h3 style="margin:0 0 10px;">Numbers Panel</h3>
          <div class="stats-grid">
            <div class="stat-row">
              <span class="stat-label">Mean of sample means</span>
              <span class="stat-value" id="meanMeans">—</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">SD of sample means</span>
              <span class="stat-value" id="sdMeans">—</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Theoretical SE</span>
              <span class="stat-value" id="theoreticalSE">—</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Number of simulations completed</span>
              <span class="stat-value" id="simCount">—</span>
            </div>
          </div>
        </div>

        <div class="panel" style="margin-top:16px;" aria-live="polite">
          <h3 style="margin:0 0 10px;">Interpretation Panel</h3>
          <div class="interp" id="interpretation">
            Run a simulation to see how the sampling distribution of <em>x-bar</em> changes.
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="plot-title" id="plotTitle">Sampling Distribution of x-bar (n = 30)</div>
        <canvas id="histCanvas" width="760" height="500">
          Your browser does not support the canvas element.
        </canvas>
      </div>
    </div>
  </div>

  <script>
    "use strict";

    const DEFAULT_N = 30;
    const DEFAULT_SIMS = 1000;
    const DEFAULT_SHAPE = "normal";
    const HIST_BINS = 30;

    const controls = {
      nSlider: document.getElementById("nSlider"),
      simSlider: document.getElementById("simSlider"),
      shapeSelect: document.getElementById("shapeSelect"),
      nValue: document.getElementById("nValue"),
      simValue: document.getElementById("simValue"),
      runBtn: document.getElementById("runBtn"),
      resetBtn: document.getElementById("resetBtn")
    };

    const output = {
      meanMeans: document.getElementById("meanMeans"),
      sdMeans: document.getElementById("sdMeans"),
      theoreticalSE: document.getElementById("theoreticalSE"),
      simCount: document.getElementById("simCount"),
      interpretation: document.getElementById("interpretation"),
      plotTitle: document.getElementById("plotTitle")
    };

    const canvas = document.getElementById("histCanvas");
    const ctx = canvas.getContext("2d");

    const bimodalStats = computeBimodalPopulationStatsNumerically();

    controls.nSlider.addEventListener("input", updateControlLabels);
    controls.simSlider.addEventListener("input", updateControlLabels);

    controls.runBtn.addEventListener("click", function () {
      const n = parseInt(document.getElementById("nSlider").value, 10);
      const simulations = parseInt(document.getElementById("simSlider").value, 10);
      const shape = document.getElementById("shapeSelect").value;
      runSimulation(n, simulations, shape);
    });

    controls.resetBtn.addEventListener("click", resetApp);

    initialize();

    function initialize() {
      controls.nSlider.value = String(DEFAULT_N);
      controls.simSlider.value = String(DEFAULT_SIMS);
      controls.shapeSelect.value = DEFAULT_SHAPE;
      updateControlLabels();
      clearOutputs();
      drawEmptyPlot(DEFAULT_N);
    }

    function updateControlLabels() {
      controls.nValue.textContent = controls.nSlider.value;
      controls.simValue.textContent = controls.simSlider.value;
      output.plotTitle.textContent = "Sampling Distribution of x-bar (n = " + controls.nSlider.value + ")";
    }

    function resetApp() {
      controls.nSlider.value = String(DEFAULT_N);
      controls.simSlider.value = String(DEFAULT_SIMS);
      controls.shapeSelect.value = DEFAULT_SHAPE;
      updateControlLabels();
      clearOutputs();
      drawEmptyPlot(DEFAULT_N);
    }

    function clearOutputs() {
      output.meanMeans.textContent = "—";
      output.sdMeans.textContent = "—";
      output.theoreticalSE.textContent = "—";
      output.simCount.textContent = "—";
      output.interpretation.innerHTML = 'Run a simulation to see how the sampling distribution of <em>x-bar</em> changes.';
    }

    function runSimulation(n, simulations, shape) {
      const sampleMeans = new Array(simulations);

      for (let i = 0; i < simulations; i++) {
        let sum = 0;
        for (let j = 0; j < n; j++) {
          sum += drawFromPopulation(shape);
        }
        sampleMeans[i] = sum / n;
      }

      const meanMeans = computeMean(sampleMeans);
      const sdMeans = computeSampleSD(sampleMeans, meanMeans);
      const theoreticalSE = getPopulationSigma(shape) / Math.sqrt(n);
      const skewness = computeMomentSkewness(sampleMeans, meanMeans, sdMeans);

      output.meanMeans.textContent = meanMeans.toFixed(2);
      output.sdMeans.textContent = sdMeans.toFixed(4);
      output.theoreticalSE.textContent = theoreticalSE.toFixed(4);
      output.simCount.textContent = String(simulations);
      output.plotTitle.textContent = "Sampling Distribution of x-bar (n = " + n + ")";

      drawHistogram(sampleMeans);
      updateInterpretation(n, shape, sdMeans, theoreticalSE, skewness);
    }

    function drawFromPopulation(shape) {
      if (shape === "normal") {
        return randomNormal(50, 10);
      }
      if (shape === "skewed") {
        return randomExponential(0.1);
      }
      // Bimodal: 50% from N(30,5), 50% from N(70,5)
      return Math.random() < 0.5 ? randomNormal(30, 5) : randomNormal(70, 5);
    }

    function getPopulationSigma(shape) {
      if (shape === "normal") return 10;
      if (shape === "skewed") return 10; // For Exp(lambda=0.1), sigma = 1/lambda = 10
      return bimodalStats.sd;
    }

    function randomNormal(mu, sigma) {
      return mu + sigma * standardNormalBM();
    }

    function standardNormalBM() {
      let u1 = 0;
      let u2 = 0;
      while (u1 === 0) u1 = Math.random();
      while (u2 === 0) u2 = Math.random();
      const r = Math.sqrt(-2 * Math.log(u1));
      const theta = 2 * Math.PI * u2;
      return r * Math.cos(theta);
    }

    function randomExponential(lambda) {
      let u = 0;
      while (u === 0) u = Math.random();
      return -Math.log(1 - u) / lambda;
    }

    function normalPDF(x, mu, sigma) {
      const z = (x - mu) / sigma;
      return Math.exp(-0.5 * z * z) / (sigma * Math.sqrt(2 * Math.PI));
    }

    function computeBimodalPopulationStatsNumerically() {
      const minX = -20;
      const maxX = 120;
      const step = 0.01;
      const steps = Math.round((maxX - minX) / step);

      let mass = 0;
      let firstMoment = 0;
      let secondMoment = 0;

      for (let i = 0; i <= steps; i++) {
        const x = minX + i * step;
        const weight = (i === 0 || i === steps) ? 0.5 : 1;
        const pdf = 0.5 * normalPDF(x, 30, 5) + 0.5 * normalPDF(x, 70, 5);

        mass += weight * pdf;
        firstMoment += weight * x * pdf;
        secondMoment += weight * x * x * pdf;
      }

      mass *= step;
      firstMoment *= step;
      secondMoment *= step;

      const mean = firstMoment / mass;
      const variance = Math.max(0, secondMoment / mass - mean * mean);

      return { mean: mean, sd: Math.sqrt(variance) };
    }

    function computeMean(arr) {
      let sum = 0;
      for (let i = 0; i < arr.length; i++) sum += arr[i];
      return sum / arr.length;
    }

    function computeSampleSD(arr, mean) {
      if (arr.length < 2) return 0;
      let ss = 0;
      for (let i = 0; i < arr.length; i++) {
        const d = arr[i] - mean;
        ss += d * d;
      }
      return Math.sqrt(ss / (arr.length - 1));
    }

    function computeMomentSkewness(arr, mean, sd) {
      if (sd === 0) return 0;
      let sum = 0;
      for (let i = 0; i < arr.length; i++) {
        const z = (arr[i] - mean) / sd;
        sum += z * z * z;
      }
      return sum / arr.length;
    }

    function updateInterpretation(n, shape, observedSD, theoreticalSE, skewness) {
      const shapeLabel = shape === "normal" ? "normal" : (shape === "skewed" ? "right-skewed" : "bimodal");
      const descriptor = classifyHistogramShape(shape, skewness);
      const relDiff = theoreticalSE === 0 ? 0 : Math.abs(observedSD - theoreticalSE) / theoreticalSE;

      let closeness = "close to";
      if (relDiff > 0.15 && relDiff <= 0.30) closeness = "reasonably close to";
      if (relDiff > 0.30) closeness = "not especially close to";

      let sentence = "With n=" + n + " and a " + shapeLabel + " population, the distribution of sample means is " + descriptor + ". ";
      sentence += "The observed SD of means (" + observedSD.toFixed(4) + ") is " + closeness + " the theoretical SE (" + theoreticalSE.toFixed(4) + "), consistent with the Central Limit Theorem.";

      if (shape !== "normal") {
        if (n >= 30) {
          sentence += " Compared with smaller n, the histogram should look tighter and more bell-shaped.";
        } else if (n <= 10) {
          sentence += " For small samples, non-normal population shape can still show through in the histogram.";
        }
      }

      output.interpretation.textContent = sentence;
    }

    function classifyHistogramShape(shape, skewness) {
      if (shape === "normal") return "approximately normal";
      const absSkew = Math.abs(skewness);
      if (absSkew < 0.35) return "approximately normal";
      if (skewness > 0) return "still somewhat right-skewed";
      return "still somewhat left-skewed";
    }

    function drawEmptyPlot(n) {
      clearCanvas();
      const dims = getPlotDims();
      drawAxes(dims, 0, 1, 0, 1, true);
      ctx.save();
      ctx.fillStyle = "#6b7280";
      ctx.font = "16px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Click Run Simulation to generate the sampling distribution.", canvas.width / 2, canvas.height / 2);
      ctx.restore();
      output.plotTitle.textContent = "Sampling Distribution of x-bar (n = " + n + ")";
    }

    function drawHistogram(values) {
      const hist = buildHistogram(values, HIST_BINS);
      clearCanvas();

      const dims = getPlotDims();
      const yMax = niceCeil(Math.max(1, hist.maxCount));
      drawAxes(dims, hist.min, hist.max, 0, yMax, false);

      const plotW = dims.plotW;
      const plotH = dims.plotH;
      const binWpx = plotW / hist.counts.length;

      ctx.save();
      ctx.fillStyle = "steelblue";
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1;

      for (let i = 0; i < hist.counts.length; i++) {
        const count = hist.counts[i];
        const barH = (count / yMax) * plotH;
        const x = dims.left + i * binWpx + 1;
        const y = dims.top + plotH - barH;
        const w = Math.max(1, binWpx - 2);

        ctx.fillRect(x, y, w, barH);
        ctx.strokeRect(x, y, w, barH);
      }
      ctx.restore();
    }

    function buildHistogram(values, bins) {
      let min = Infinity;
      let max = -Infinity;

      for (let i = 0; i < values.length; i++) {
        if (values[i] < min) min = values[i];
        if (values[i] > max) max = values[i];
      }

      if (min === max) {
        min -= 0.5;
        max += 0.5;
      }

      const range = max - min;
      const pad = range * 0.03;
      min -= pad;
      max += pad;

      const width = (max - min) / bins;
      const counts = new Array(bins).fill(0);

      for (let i = 0; i < values.length; i++) {
        let idx = Math.floor((values[i] - min) / width);
        if (idx < 0) idx = 0;
        if (idx >= bins) idx = bins - 1;
        counts[idx]++;
      }

      let maxCount = 0;
      for (let i = 0; i < counts.length; i++) {
        if (counts[i] > maxCount) maxCount = counts[i];
      }

      return { min, max, counts, maxCount };
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function getPlotDims() {
      const left = 78;
      const right = 24;
      const top = 24;
      const bottom = 72;
      return {
        left,
        right,
        top,
        bottom,
        plotW: canvas.width - left - right,
        plotH: canvas.height - top - bottom
      };
    }

    function drawAxes(dims, xMin, xMax, yMin, yMax, placeholder) {
      const x0 = dims.left;
      const y0 = dims.top + dims.plotH;
      const x1 = dims.left + dims.plotW;
      const y1 = dims.top;

      ctx.save();
      ctx.strokeStyle = "#111827";
      ctx.fillStyle = "#111827";
      ctx.lineWidth = 1.2;
      ctx.font = "13px Arial";

      // Axes lines
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y0);
      ctx.moveTo(x0, y0);
      ctx.lineTo(x0, y1);
      ctx.stroke();

      // X ticks (at least 5; here 6)
      const xTicks = 6;
      const xRange = xMax - xMin;
      for (let i = 0; i < xTicks; i++) {
        const frac = i / (xTicks - 1);
        const x = x0 + frac * dims.plotW;
        const val = xMin + frac * xRange;

        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y0 + 6);
        ctx.stroke();

        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillText(formatXAxisTick(val, xRange), x, y0 + 9);
      }

      // Y ticks
      const yTicks = 6;
      const yRange = yMax - yMin;
      for (let i = 0; i < yTicks; i++) {
        const frac = i / (yTicks - 1);
        const y = y0 - frac * dims.plotH;
        const val = yMin + frac * yRange;

        ctx.beginPath();
        ctx.moveTo(x0 - 6, y);
        ctx.lineTo(x0, y);
        ctx.stroke();

        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        ctx.fillText(String(Math.round(val)), x0 - 10, y);
      }

      // X-axis label
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.font = "15px Arial";
      ctx.fillText("Sample Mean (x-bar)", x0 + dims.plotW / 2, canvas.height - 10);

      // Y-axis label
      ctx.save();
      ctx.translate(22, y1 + dims.plotH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.font = "15px Arial";
      ctx.fillText("Frequency", 0, 0);
      ctx.restore();

      // Subtle gridlines (skip if placeholder to keep it cleaner)
      if (!placeholder) {
        ctx.save();
        ctx.strokeStyle = "#e5e7eb";
        ctx.lineWidth = 1;
        for (let i = 1; i < yTicks; i++) {
          const frac = i / (yTicks - 1);
          const y = y0 - frac * dims.plotH;
          ctx.beginPath();
          ctx.moveTo(x0, y);
          ctx.lineTo(x1, y);
          ctx.stroke();
        }
        ctx.restore();
      }

      ctx.restore();
    }

    function formatXAxisTick(value, range) {
      if (range < 2) return value.toFixed(2);
      if (range < 20) return value.toFixed(1);
      return value.toFixed(0);
    }

    function niceCeil(value) {
      if (value <= 1) return 1;
      const exponent = Math.floor(Math.log10(value));
      const base = Math.pow(10, exponent);
      const fraction = value / base;

      let niceFraction;
      if (fraction <= 1) niceFraction = 1;
      else if (fraction <= 2) niceFraction = 2;
      else if (fraction <= 5) niceFraction = 5;
      else niceFraction = 10;

      return niceFraction * base;
    }
  </script>
</body>
</html>
